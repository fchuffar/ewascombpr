---
title: "Methylome analysis"
subtitle: "ewas + neighb"
author: "Florent Chuffart, Ekatarina Flin, Fabien Jossaud"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
---



```{r, echo=FALSE, eval=TRUE}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>", fig.width=9, fig.height=6, eval=TRUE, echo=FALSE, results="hide", warning=FALSE)
source("../R/common.R")
source("config")
if (file.exists("00_local_config")) {source("00_local_config")}
# source("modelcall.R")
```


```{r inputs}
if (!exists("study_filename"))  study_filename = "study_GSE42861.rds"   ;
if (!exists("model_formula"))   model_formula = "meth~age"              ;
if (!exists("model_func_name")) model_func_name = "modelcalllm"         ;

if (file.exists(paste0(model_func_name, ".R"))) {
  source(paste0(model_func_name, ".R"))
}
```

```{r outputs}
prefix = paste0(study_filename, "_", model_func_name, "_", model_formula)
bed_ewas_filename = paste0("ewas4combp_", prefix, ".bed")
rds_ewas_filename = paste0("ewas_", prefix, ".rds")
```

```{r loading data}
print(paste0("Loading ", study_filename, "..."))
s = mreadRDS(study_filename)
```

# Objective

The main objective of this vignette is to reduce the number of probes of the study `r study_filename` : 

  - we perform an ewas on the dataset using the model : `r model_formula` (computed by `r model_func_name`).
  - parameter `FILTER_SEXUAL_CHR` is set to `r FILTER_SEXUAL_CHR`
  - ewas results are exported as: [`r bed_ewas_filename`](./`r bed_ewas_filename`)
 
model is caracterised by the cofactor `r cofact = rownames(attr(stats::terms(as.formula(model_formula)), "factor"))[2]; print(cofact)` taking is values in `r levels(s$exp_grp[,cofact])`.


# Method 

The analysis of methylation is performed in two main steps. 

First, we realized the epigenome-wide association study (EWAS) to identify the differentially methylated individual sites. This method aims to calculate a linear regression model between the selected parameters `r model_formula`, and to obtain the corresponding p-values. The distribution of the p-values is then compared to the uniform distribution.


# Data

We use the methylation data serialized in the file `r study_filename`, containing `r nrow(s$exp_grp)` samples caracterized by their Illumina bead chip methylome (`r nrow(s$platform)` methylation sites with annotations).

```{r data, results="verbatim"}
if (FILTER_SEXUAL_CHR) {
  dim(s$data)
  s$platform = s$platform[!s$platform[,1]%in%c("chrX","chrY"),]
  s$data = s$data[rownames(s$platform),]  
  dim(s$data)
} 
d = s$data
e = s$exp_grp
pf = s$platform

pf = pf[rownames(d),]

pf_orig = pf
pf_chr_colname = colnames(pf_orig)[1]
pf_pos_colname = colnames(pf_orig)[2]

print("# dim meth matrix:")
dim(d)

print("# experimental grouping:")
head(e)
dim(e)

for (f in rownames(attr(stats::terms(as.formula(model_formula)), "factor"))[-1]) {
  if (is.character(e[[f]])) {
    print(paste0("Converting ", f, " as factor."))
    e[[f]] = factor(e[[f]], levels=as.character(na.omit(unique(e[[f]]))))
  }
}

layout(1, respect=TRUE)
for (f in rownames(attr(stats::terms(as.formula(model_formula)), "factor"))[-1]) {
  if (is.factor(e[[f]])) {
    barplot(table(e[[f]], useNA="ifany"), las=2)    
  } else if (is.numeric(e[[f]])) {
    plot(density(e[[f]], na.rm=TRUE), main=f)
  } else {
    stop(paste0("Covariate ", f, " is not factor nor numeric."))
  }
}
```


# Identification of differentially methylated sites using EWAS


`r model_formula`


```{r ewas}
USE_PARAPPLY = TRUE
if (length(rownames(attr(stats::terms(as.formula(model_formula)), "factor"))) < 3) {
  nb_fact_of_interest = 1
} else if (rownames(attr(stats::terms(as.formula(model_formula)), "factor"))[-1][2] == "hb") {
  nb_fact_of_interest = 2
} else {
  nb_fact_of_interest = 1  
}
ewas_orig = ewas = mewas_func2(d=d, e=e, USE_PARAPPLY=USE_PARAPPLY, model_formula=model_formula, model_func_name=model_func_name, nb_fact_of_interest=nb_fact_of_interest)
if (nrow(d)==nrow(ewas)) {
  rownames(ewas) = rownames(ewas_orig) = rownames(d)  
} else {
  stop(paste0("ewas do not have the same dimension as d."))
}

print("***********Before")
saveRDS(ewas, rds_ewas_filename)
print("***********After")


dim(ewas)
ewas = ewas[!is.na(ewas[,"lpv"]),]
dim(ewas)
head(ewas)
plot(lpv~beta, ewas, main=model_formula)


if (FILTER_EWAS_FOR_DMR_CANDIDATE) {
  dmr_candidates = mbuild_dmr_candidates(pf=pf, pf_chr_colname="chr", pf_pos_colname="pos")
  dmr_candidates = dmr_candidates[sapply(dmr_candidates, length) > 1]
  idx_probes = unique(unlist(dmr_candidates))
  idx_probes = intersect(idx_probes, rownames(ewas))
} else {
  idx_probes = rownames(ewas)
}

ewas = ewas[idx_probes,]

dim(ewas)
```

```{r ewas_fabien, eval=FALSE}
y_key = "model05"
confounders = NULL

cpg_matrix = d
if (!is.null(confounders)) {
  design_matrix <- model.matrix(formula(paste0("~", y_key, "+", paste0(confounders, collapse="+"))), e)    
} else {
  design_matrix <- model.matrix(formula(paste0("~", y_key)), e)    
}
design_matrix = design_matrix[1:6,]
cpg_matrix = cpg_matrix[,rownames(design_matrix)]
cpg_matrix = cpg_matrix[!apply(is.na(cpg_matrix), 1, any),]
dim(design_matrix)
dim(cpg_matrix)
head(cpg_matrix)
idx_probes =  rownames(cpg_matrix)
e[colnames(cpg_matrix),]
# cpg_matrix = cpg_matrix - apply(cpg_matrix, 1, mean)
cpg_matrix = cpg_matrix - apply(cpg_matrix[,1:3], 1, mean) # TO FORCE "range(fit$p.value[,1])" to "[1] 1 1" 

apply(cpg_matrix, 1, mean)

fit = limma::lmFit(cpg_matrix, design_matrix)
fit = limma::eBayes(fit) # compute moderated t-statistics, moderated F-statistic, and log-odds of differential expression by empirical Bayes moderation of the standard errors towards a global value
head(fit$coefficients)
range(fit$p.value[,1])




d = cpg_matrix
e = e[colnames(d),]
USE_PARAPPLY = TRUE
if (length(rownames(attr(stats::terms(as.formula(model_formula)), "factor"))) < 3) {
  nb_fact_of_interest = 1
} else if (rownames(attr(stats::terms(as.formula(model_formula)), "factor"))[-1][2] == "hb") {
  nb_fact_of_interest = 2
} else {
  nb_fact_of_interest = 1  
}
ewas_orig = ewas = mewas_func2(d=d, e=e, USE_PARAPPLY=USE_PARAPPLY, model_formula=model_formula, model_func_name=model_func_name, nb_fact_of_interest=nb_fact_of_interest)
if (nrow(d)==nrow(ewas)) {
  rownames(ewas) = rownames(ewas_orig) = rownames(d)  
} else {
  stop(paste0("ewas do not have the same dimension as d."))
}
print("***********Before")
saveRDS(ewas, rds_ewas_filename)
print("***********After")

dim(ewas)
ewas = ewas[!is.na(ewas[,"lpv"]),]
dim(ewas)
head(ewas)
plot(lpv~beta, ewas, main=model_formula)











plot(fit$coefficients[,2], ewas[,"beta"])

plot(-log10(fit$F.p.value),   ewas[,"lpv"], )
plot(-log10(fit$p.value[,2]), ewas[,"lpv"], )



plot(lpv~beta, ewas, main=model_formula)

plot(fit$coefficients[,2], -log10(fit$p.value[,2]))

plot(ewas[,"lpv"], -log10(fit$p.value[,2]))


```








```{r plot_ewas}
layout(matrix(1:4, 2, byrow=TRUE), respect=TRUE,)
plot(ewas[,"beta"], ewas[,"lpv"], main="Volcano plot", pch=".")
plot(density(ewas[,"lpv"]), main="lpv distribution", pch=".", xlim=c(0,100))
plot(density(10^-ewas[,"lpv"]), main="pv distribution", pch=".", xlim=c(0,1))
plot(sort(-log10(runif(nrow(ewas)))) , sort(ewas[,"lpv"]), main="million dollar plot", pch=".")
abline(a=0,b=1, lty=2, col="grey")
```

```{r build_bed}
head(ewas)
head(pf[,1:6])
lpval = ewas[,"lpv"]

pval = 10^-lpval

# build and write bed file
bed = pf[rownames(ewas),1:2] # Warning, here pf is global, it must be arg and indexed!!
head(bed)
bed[,3] = bed[,2]+1
bed$probes = names(pval)
bed$pval = pval
bed$strand = "+"
colnames(bed) = c("#chrom", "start", "end", "probes", "pval", "strand")
head(bed)

# write ewas res for combp
bed[,1] = as.character(bed[,1])
bed = bed[order(bed[,1], bed[,2]),]
write.table(bed,file=bed_ewas_filename , sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE)
# bed_on_disk = read.table(bed_ewas_filename, sep="\t", header=TRUE)
```

EWAS results is exporetd as: 
[`r bed_ewas_filename`](./`r bed_ewas_filename`)


# Session Information

```{r, results="verbatim"}
sessionInfo()
```




